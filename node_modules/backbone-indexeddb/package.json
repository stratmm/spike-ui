{
  "author": {
    "name": "Julien Genestoux",
    "email": "julien@superfeedr.com",
    "url": "http://ouvre-boite.com"
  },
  "name": "backbone-indexeddb",
  "description": "An backbone adapter for indexeddb. Useless for most people untile indexeddb is ported to the browser",
  "version": "0.0.13",
  "repository": {
    "type": "git",
    "url": "git://github.com/superfeedr/indexeddb-backbonejs-adapter.git"
  },
  "main": "backbone-indexeddb.js",
  "dependencies": {
    "backbone": "*",
    "underscore": "*"
  },
  "devDependencies": {},
  "optionalDependencies": {},
  "readme": "[![build status](https://secure.travis-ci.org/superfeedr/indexeddb-backbonejs-adapter.png)](http://travis-ci.org/superfeedr/indexeddb-backbonejs-adapter)\nThis is an [IndexedDB](http://www.w3.org/TR/IndexedDB/) adapter for [Backbone.js](http://documentcloud.github.com/backbone/).\n\n# Warnings\n\n*It lacks a lot of documentation, so it's good idea to look at the tests if you're interested in using it.*\n\n# Browser support and limitations\n\nIn Firefox, `backbone-indexeddb.js` should work from 4.0 up; but it\n\n* won't work at all with local files (`file:///` URLs). As soon as you try to create the database it will raise an error `Permission denied for <file://> to create wrapper for object of class UnnamedClass`\n* will ask the user for permission before creating a database\n* requests permission again when the database grows to a certain size (50MB by default). After this the disk is the limit, unlike the fairly concrete and currently fixed limit (5MB by default) that `localStorage` gets (which will just fail after that with no way to ask the user to increase it).\n\nChrome 11 and later are supported. (Chrome 9 and 10 should also work but are untested.) In Chrome 11, `backbone-indexeddb.js`\n\n* will work with `file:///` URLs, but\n* poses some hard size limit (5MB? quantity untested) unless Chrome is started with `--unlimited-quota-for-indexeddb`, with apparently no way to request increasing the quota.\n\nIE10 support has been added thanks to [lcalvy](https://github.com/lcalvy).\n\nOther browsers implementing the Indexed Database API Working Draft should work, with some of these limitations possibly cropping up or possibly not. Support and ease of use is expected to improve in upcoming releases of browsers.\n\n# Tests\n\nJust open the <code>/tests/test.html</code> in your favorite browser. (or serve if from a webserver for Firefox, which can't run indexedDB on local file.)\n\n# Node\n\nThis is quite useless to most people, but there is also an npm module for this. It's useless because IndexedDB hasn't been (yet?) ported to node.js.\nIt can be used in the context of [browserify](https://github.com/substack/node-browserify) though... and this is exactly why this npm version exists.\n\n# Implementation\n\n## Database & Schema\n\nBoth your Backbone model and collections need to point to a `database` and a `storeName` attributes that are used by the adapter.\n\nThe `storeName` is the name of the store used for the objects of this Model or Collection. You _should_ use the same `storeName` for the model and collections of that same model.\n\nThe `database` is an object literal that define the following :\n\n * `id` : and unique id for the database\n * `description` :  a description of the database [OPTIONAL]\n * `migrations` : an array of migration to be applied to the database to get the schema that your app needs.\n\nThe migrations are object literals with the following :\n\n * `version` : the version of the database once the migration is applied.\n * `migrate` : a Javascript function that will be called by the driver to perform the migration. It is called with a `IDBDatabase` object, a `IDBVersionChangeRequest` object and a function that needs to be called when the migration is performed, so that the next migration can be executed.\n * `before` *[optional]* : a Javascript function that will be called with the database, before the transaction is run. It's useful to update fields before updating the schema.\n * `after` *[optional]* : a Javascript function that will be called with the database, after the transaction has been run. It's useful to update fields after updating the schema.\n\n### Example\n\n\tvar database = {\n\t\tid: \"my-database\",\n\t\tdescription: \"The database for the Movies\",\n\t\tmigrations : [\n\t\t\t{\n\t\t\t\tversion: \"1.0\",\n\t\t\t\tbefore: function(db, next) {\n\t\t\t\t    // Do magic stuff before the migration. For example, before adding indices, the Chrome implementation requires to set define a value for each of the objects.\n\t\t\t\t    next();\n\t\t\t\t}\n\t\t\t\tmigrate: function(db, versionRequest, next) {\n\t\t\t\t\tvar store = db.createObjectStore(\"movies\"); // Adds a store, we will use \"movies\" as the storeName in our Movie model and Collections\n\t\t\t\t\tnext();\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tversion: \"1.1\",\n\t\t\t\tmigrate: function(db, versionRequest, next) {\n\t\t\t\t\tvar store = versionRequest.transaction.objectStore(\"movies\")\n\t\t\t\t\tstore.createIndex(\"titleIndex\", \"title\", { unique: true});  // Adds an index on the movies titles\n\t\t\t\t\tstore.createIndex(\"formatIndex\", \"format\", { unique: false}); // Adds an index on the movies formats\n\t\t\t\t\tstore.createIndex(\"genreIndex\", \"genre\", { unique: false}); // Adds an index on the movies genres\n\t\t\t\t\tnext();\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}\n\n## Models\n\nNot much change to your usual models. The only significant change is that you can now fetch a given model with its id, or with a value for one of its index.\n\nFor example, in your traditional backbone apps, you would do something like :\n\n\tvar movie = new Movie({id: \"123\"})\n\tmovie.fetch()\n\nto fetch from the remote server the Movie with the id `123`. This is convenient when you know the id. With this adapter, you can do something like\n\n\tvar movie = new Movie({title: \"Avatar\"})\n\tmovie.fetch()\n\nObviously, to perform this, you need to have and index on `title`, and a movie with \"Avatar\" as a title obviously. If the index is not unique, the database will only return the first one.\n\n## Collections\n\nI added a lot of fun things to the collections, that make use of the `options` param used in Backbone to take advantage of IndexedDB's features, namely **indices, cursors and bounds**.\n\nFirst, you can `limit` and `offset` the number of items that are being fetched by a collection.\n\n\tvar theater = new Theater() // Theater is a collection of movies\n\ttheater.fetch({\n\t\toffset: 1,\n\t\tlimit: 3,\n\t\tsuccess: function() {\n\t\t\t// The theater collection will be populated with at most 3 items, skipping the first one\n\t\t}\n\t});\n\nYou can also *provide a range* applied to the id.\n\n\tvar theater = new Theater() // Theater is a collection of movies\n\ttheater.fetch({\n\t\trange: [\"a\", \"b\"],\n\t\tsuccess: function() {\n\t\t\t// The theater collection will be populated with all the items with an id comprised between \"a\" and \"b\" (\"alphonse\" is between \"a\" and \"b\")\n\t\t}\n\t});\n\nYou can also get *all items with a given value for a specific value of an index*. We use the `conditions` keyword.\n\n\tvar theater = new Theater() // Theater is a collection of movies\n\ttheater.fetch({\n\t\tconditions: {genre: \"adventure\"},\n\t\tsuccess: function() {\n\t\t\t// The theater collection will be populated with all the movies whose genre is \"adventure\"\n\t\t}\n\t});\n\nYou can also *get all items for which an indexed value is comprised between 2 values*. The collection will be sorted based on the order of these 2 keys.\n\n\tvar theater = new Theater() // Theater is a collection of movies\n\ttheater.fetch({\n\t\tconditions: {genre: [\"a\", \"e\"]},\n\t\tsuccess: function() {\n\t\t\t// The theater collection will be populated with all the movies whose genre is \"adventure\", \"comic\", \"drama\", but not \"thriller\".\n\t\t}\n\t});\n\nYou can also *get all items after a certain object (excluding that object), or from a certain object (including) to a certain object (including)* (using their ids). This combined with the addIndividually option allows you to lazy load a full collection, by always loading the next element.\n\n    \tvar theater = new Theater() // Theater is a collection of movies\n    \ttheater.fetch({\n    \t\tfrom: new Movie({id: 12345, ...}),\n    \t\tafter: new Movie({id: 12345, ...}),\n    \t\tto: new Movie({id: 12345, ...}),\n    \t\tsuccess: function() {\n    \t\t\t// The theater collection will be populated with all the movies whose genre is \"adventure\", \"comic\", \"drama\", but not \"thriller\".\n    \t\t}\n    \t});\n\n\nYou can also obviously combine all these.\n\n## Optional Persistence\nIf needing to persist via ajax as well as indexed-db, just override your model's sync to use ajax instead.\n\n```coffeescript\nclass MyMode extends Backbone.Model\n\n  sync: Backbone.ajaxSync\n```\n\nAny more complex dual persistence can be provided in method overrides, which could eventually drive out the design for a multi-layer persistence adapter.\n\n\n\n",
  "readmeFilename": "README.markdown",
  "bugs": {
    "url": "https://github.com/superfeedr/indexeddb-backbonejs-adapter/issues"
  },
  "_id": "backbone-indexeddb@0.0.13",
  "dist": {
    "shasum": "b64a62982c8deca7685197e1071f321a787a8fc2"
  },
  "_from": "backbone-indexeddb@",
  "_resolved": "https://registry.npmjs.org/backbone-indexeddb/-/backbone-indexeddb-0.0.13.tgz"
}
